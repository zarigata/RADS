// RADS Importer: scaffold to convert Python/Node.js into RADS-friendly stubs
// Usage: rads tools/import-to-rads/import-to-rads.rads <source_file>

blast usage() {
    echo("Usage: rads import-to-rads <source_file.py|source_file.js>");
    echo("This is a lightweight scaffold that will:");
    echo("  - detect language (Python / Node.js)");
    echo("  - outline detected functions");
    echo("  - emit RADS-styled stubs you can refine");
}

blast detect_language(str path) -> str {
    if (path.ends_with(".py")) return "python";
    if (path.ends_with(".js")) return "node";
    return "unknown";
}

blast emit_stub(str lang, str path) {
    echo("ðŸ” Detected: " + lang + " | Source: " + path);
    echo("âš ï¸ Note: automatic AST conversion is not implemented yet; this emits a starter RADS skeleton.");
    echo("");
    echo("// RADS stub generated from " + path);
    echo("blast main() {");
    echo("    echo(\"TODO: port logic from " + path + " (" + lang + ")\");");
    echo("    // Detected functions (best-effort):");
    echo("}");
}

blast parse_params(str sig) -> array<str> {
    turbo params = array<str>();
    turbo l = sig.indexOf("(");
    turbo r = sig.indexOf(")");
    if (l < 0 || r < 0 || r <= l) return params;
    turbo inside = sig.substring(l + 1, r).trim();
    if (inside.length() == 0) return params;
    turbo parts = inside.split(",");
    cruise (i in 0..parts.length()) {
        turbo p = parts[i].trim();
        if (p.length() > 0) params.push(p);
    }
    return params;
}

blast detect_functions(str source, str lang) -> array<array<str>> {
    // Ultra-lightweight regex-ish scanning (no full parser)
    // returns array of [name, params_as_string]
    turbo funcs = array<array<str>>();
    turbo lines = source.split("\n");
    cruise (i in 0..lines.length()) {
        turbo str line = lines[i].trim();
        if (lang == "python" && line.starts_with("def ")) {
            // def name(
            turbo parts = line.split(" ");
            if (parts.length() > 1) {
                turbo name = parts[1];
                turbo idx = name.indexOf("(");
                if (idx >= 0) name = name.substring(0, idx);
                turbo params = parse_params(line);
                funcs.push(array<str> { name, params.join(", ") });
            }
        }
        if (lang == "node" && (line.starts_with("function ") || line.contains("=>"))) {
            // function name(
            if (line.starts_with("function ")) {
                turbo parts = line.split(" ");
                if (parts.length() > 1) {
                    turbo name = parts[1];
                    turbo idx = name.indexOf("(");
                    if (idx >= 0) name = name.substring(0, idx);
                    turbo params = parse_params(line);
                    funcs.push(array<str> { name, params.join(", ") });
                }
            } else if (line.contains("=>")) {
                // const foo = (...) => {
                turbo eq = line.indexOf("=");
                if (eq > 0) {
                    turbo left = line.substring(0, eq).trim();
                    // take last token
                    turbo parts = left.split(" ");
                    if (parts.length() > 0) {
                        turbo name = parts[parts.length()-1];
                        turbo params = parse_params(line);
                        funcs.push(array<str> { name, params.join(", ") });
                    }
                }
            }
        }
    }
    return funcs;
}

blast emit_functions(array<array<str>> funcs) {
    if (funcs.length() == 0) {
        echo("// No functions detected; add your own stubs");
        return;
    }
    cruise (i in 0..funcs.length()) {
        turbo f = funcs[i][0];
        turbo params = funcs[i][1];
        echo("blast " + f + "(" + params + ") {");
        echo("    echo(\"TODO: port function: " + f + "\");");
        echo("}");
        echo("");
    }
}

blast main() {
    // Minimal arg parsing (expects one argument)
    turbo args = env.args();
    if (args.length() < 2) {
        usage();
        return;
    }

    turbo str path = args[1];
    turbo str lang = detect_language(path);

    if (lang == "unknown") {
        echo("âŒ Unsupported file type. Please provide .py or .js");
        return;
    }

    // read source file
    turbo str source = io.read_file(path);
    emit_stub(lang, path);
    turbo funcs = detect_functions(source, lang);
    emit_functions(funcs);
}
